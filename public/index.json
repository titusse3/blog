[{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"","permalink":"http://localhost:1313/posts/project_python/","summary":"","title":""},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"","title":""},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"title: \u0026ldquo;Fond Parallaxe\u0026rdquo; date: \u0026ldquo;2025-02-24\u0026rdquo; tags: [Raylib, C] series : [\u0026ldquo;Themes Guide\u0026rdquo;] ShowToc: true ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003ch2 id=\"showtoc-true\"\u003etitle: \u0026ldquo;Fond Parallaxe\u0026rdquo;\ndate: \u0026ldquo;2025-02-24\u0026rdquo;\ntags: [Raylib, C]\nseries : [\u0026ldquo;Themes Guide\u0026rdquo;]\nShowToc: true\u003c/h2\u003e","title":""},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"","title":"Fond Parallaxe"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"","title":"Extraction de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"","title":"Extraction de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"","title":"Extraction de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"","title":"Extraction de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"","title":"Extraction d'information du Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu.\u003c/p\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\u003c/p\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\nDescription du problème ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\nDescription du problème ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\nDescription du problème Dans le mini-jeu Naruto RP\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e\u003c/p\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information de Coffre"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cette article expliquera le plus en détaille la mise en place de ce projet python disponible .\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCette article expliquera le plus en détaille la mise en place de ce projet python disponible .\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3?tab=repositories\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre. Les contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter un grand nombre de ressource. ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter un grand nombre de ressource. ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter un grand nombre de fonctionnalité. ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information d'image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nObjectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1 │ ├── ... │ ├── modulesN │ ├── ressources │ └── main.py └── tests/ └── css/ ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1/ │ ├── ... │ ├── modulesN/ │ ├── ressources/ │ └── main.py └── tests/ ├── integration_tests/ └── ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1/ │ ├── ... │ ├── modulesN/ │ ├── ressources/ │ └── main.py └── tests/ ├── integration_tests/ └── unit_tests/ ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1/ │ ├── ... │ ├── modulesN/ │ ├── ressources/ │ └── main.py └── tests/ ├── system_tests/ ├── integration_tests/ └── unit_tests/ ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1/ │ ├── ... │ ├── modulesN/ │ ├── ressources/ │ └── main.py └── tests/ ├── system_tests/ ├── integration_tests/ └── unit_tests/ ","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1/ │ ├── ... │ ├── modulesN/ │ ├── ressources/ │ └── main.py └── tests/ ├── system_tests/ ├── integration_tests/ └── unit_tests/ On sépare bien la partie des tests de celle du projet.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1/ │ ├── ... │ ├── modulesN/ │ ├── ressources/ │ └── main.py └── tests/ ├── system_tests/ ├── integration_tests/ └── unit_tests/ On sépare bien la partie des tests de celle du projet.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1/ │ ├── ... │ ├── modulesN/ │ ├── ressources/ │ └── main.py └── tests/ ├── system_tests/ ├── integration_tests/ └── unit_tests/ On sépare bien la partie des tests de celle du projet.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1/ │ ├── ... │ ├── modulesN/ │ ├── ressources/ │ └── main.py └── tests/ ├── system_tests/ ├── integration_tests/ └── unit_tests/ On sépare bien la partie des tests de celle du projet. Pour la partie test, le module Pytest est utiliser.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"},{"content":"Le jeu Garry\u0026rsquo;s mod, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu. Cet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : dépôt GitHub.\nDescription du problème Dans le mini-jeu Naruto RP, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments. Il vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune API n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\nPour exemple, voici à quoi ressemble le contenue total d\u0026rsquo;un telle coffre :\nFragementation du problème J\u0026rsquo;ai donc choisie de fragmenter le problème de la façon suivante:\nExtraction de la partie de l\u0026rsquo;image représentant un item, Récupération du nombre de cette item, Mise en forme des résultats Objectif L\u0026rsquo;objectif tous d\u0026rsquo;abord est de récupérer pour chaqu\u0026rsquo;une des ressources du coffres leur nombres. Je veux bien évidement que je n\u0026rsquo;aille besoin d\u0026rsquo;aucune intéraction humaine, si ce n\u0026rsquo;est de donner le chemin du dossier ou ce trouve l\u0026rsquo;ensemble des captures d\u0026rsquo;écran du coffre.\nLes contraites pour le projet sont les suivantes:\nUne bonne architectures de projet python, Un programme ne n\u0026rsquo;éssécitant pas un grand nombre de ressources, La possibilité de poursuivre le projet pour y ajouter des fonctionnalités. Architecture du projet python Après quelque recherche sur les divers architectures recommander pour un projet python, j\u0026rsquo;ai choisie celui qui me convenait le mieux. Pour cela, j\u0026rsquo;ai opter pour l\u0026rsquo;architecture suivante:\n. ├── project/ │ ├── modules1/ │ ├── ... │ ├── modulesN/ │ ├── ressources/ │ └── main.py └── tests/ ├── system_tests/ ├── integration_tests/ └── unit_tests/ On sépare bien la partie des tests de celle du projet. Pour la partie test, le module Pytest est utiliser.\n","permalink":"http://localhost:1313/posts/chest_recognition/","summary":"\u003cp\u003eLe jeu \u003cem\u003eGarry\u0026rsquo;s mod\u003c/em\u003e, est une sorte de platforme où l\u0026rsquo;on peut retrouver de nombreux mini-jeu. Cette article traite de la mise en place d\u0026rsquo;une extraction des ressources présentes dans d\u0026rsquo;image d\u0026rsquo;un coffre de ce jeu.\nCet article expliquera en détail la mise en place de ce projet Python, disponible sur GitHub : \u003ca href=\"https://github.com/titusse3/chest-reco\"\u003edépôt GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"description-du-problème\"\u003eDescription du problème\u003c/h1\u003e\n\u003cp\u003eDans le mini-jeu \u003cem\u003eNaruto RP\u003c/em\u003e, il existe des coffres, dans lequel on peut stocker des ressources. Ces ressources qui permettre de construire d\u0026rsquo;autre éléments.\nIl vient très vite le problème de savoir combien de ces éléments je peux créer avec mon coffre actuelle. Vue qu\u0026rsquo;aucune \u003cstrong\u003eAPI\u003c/strong\u003e n\u0026rsquo;est disponible, j\u0026rsquo;ai donc décider de mettre en place une petite application d\u0026rsquo;extraction d\u0026rsquo;information de capture d\u0026rsquo;écran pris des coffres.\u003c/p\u003e","title":"Extraction d'information sur image (Chest-Reco)"},{"content":"\nLes grands modèles de langues (LLM) sont très probablement la technologie la plus utilisée de ces cinq dernières années. Introduit au public par son représentant le plus connu ChatGPT en 2022. Ils sont devenus des outils presque indispensables pour certains.\nBien que ces outils soient très impressionnants, ils admettent encore de nombreux défauts. L\u0026rsquo;hallucination, la Cut-off Date, date de fin d\u0026rsquo;entrainement du modèle. Ce qui implique que les informations postérieures à l\u0026rsquo;entrainement ne seront pas accessibles par le modèle.\nGénération augmentée de récupération (RAG) Une solution aux problèmes cités ci-dessus peut être vue dans le mécanisme RAG. Ce système vise à ajouter des ressources/ connaissances supplémentaires au modèle par le biais de documents. Ce qui est intéressant pour ne pas avoir à re-entrainer un LLM, ce qui serait bien trop couteux en ressources. La solution qui implique le ré-entrainement se nomme le Fine-tunining mais elle ne sera pas abordée ici.\nLe fonctionnement d\u0026rsquo;un RAG se découpe en trois grandes étapes. La première, l\u0026rsquo;indexation (indexing) des ressources/ documents ajoutés. Cette phase peut être vue comme une extraction des connaissances présentes dans les documents. De plus, cette extraction est suivie par un rangement aillant pour but de rendre plus rapide leur récupération future. Pour une explication détaillée de cette étape utilisant un graphe de connaissance (KG) voir l\u0026rsquo;article GraphRAG, pour l\u0026rsquo;utilisation d\u0026rsquo;une base de données vectorielle se référer à l\u0026rsquo;article VectorRAG. Après la phase d\u0026rsquo;indexing, le RAG attend maintenant une entrée utilisateur. Une fois cette requête obtenue, on essaye de récupérer dans les ressources indexées, celles qui sont concernées par cette entrée. Une fois ce prompt mis en place, il est envoyer au LLM. Un exemple de RAG est donné par la figure ci-dessous, celle-ci est la version la plus simple appelée aussi RAG naïve. Les étapes évoquées précédemment sont présentes dans toutes les versions de RAG. La suite de cet article correspond à une description des modifications de cette architecture RAG.\nAdvanced RAG La différence entre le naïve RAG et le advanced ne réside que dans l\u0026rsquo;ajout des étapes de pre-retrival et post-retrival. L\u0026rsquo;étape de pre-retrival correspond à un prétraitement de la requête de l\u0026rsquo;utilisateur. Que ce soit pour améliorer les requêtes sur les documents indexés. Où même la rendre plus intéligible pour le LLM en passant par du prompt ingeniering.\nLa phase de post-retrival correspond quant à elle au filtrage ainsi qu\u0026rsquo;àla mise en valeur des informations obtenues sur les documents indexés. La figure ci-dessous représente un Advanced RAG.\nModular RAG De la même manière que les Advandced RAG, les Modular RAGont pour objectif d\u0026rsquo;ajouter des étapes à notre mécanisme. Cela va même plus loin, certains supprime/ modifie même certaines étapes des Naïve RAG, Advanced RAG. Il s\u0026rsquo;agit du type de RAG qui est actuellement le plus utilisé.\n","permalink":"http://localhost:1313/posts/rag_definition/","summary":"Les LLM comme ChatGPT sont puissants, mais limités. Les RAG (Retrieval-Augmented Generation) améliorent leurs réponses en leur fournissant des documents à la volée, sans ré-entraînement. L’article explore les variantes des RAG — naïf, avancé, modulaire — afin de palier aux principaux défauts des LLM modernes.","title":"Génération Augmentée de récupération (RAG)"},{"content":"Dans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau Quarto. Aux côtés de mon collègue E. HADDAG, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité de ce projet a été réalisée en C de l\u0026rsquo;interface à la mise en place du modèle.\nSommaire Cet article se composera en trois parties :\nL\u0026rsquo;explication des règles du jeu. Une présentation de l\u0026rsquo;implémentation de celui-ci. La mise en place de l’interface graphique à l’aide de la librairie C, Raylib. Règles Le jeu du Quarto se joue à deux joueurs sur un plateau 4×4. Les deux joueurs ont à disposition 16 pièces, toutes différentes. Chacune de ces pièces dispose de quatre caractéristiques dont les valeurs possibles sont les suivantes :\nCouleur : Rouge ou Bleu, Forme : Cylindrique ou Cubique, Taille : Grande ou Petite, Type : Pleine ou Creuse. Les 16 pièces sont donc toutes les combinaisons possibles de ces caractéristiques. L\u0026rsquo;image ci-dessous nous donne une représentation de ces pièces.\nImage provenant d\u0026rsquo;un document Universitaire sur le Quarto.\nUne partie de jeu se déroule de la façon suivante :\nLe joueur Max choisit une pièce qu\u0026rsquo;il offre à son adversaire. Le joueur Min place cette pièce sur le plateau et donne une seconde pièce dans celles restantes à Max. Max réitaire les opérations de Min. La partie se termine lorsque l\u0026rsquo;un des deux joueurs réussit à aligner quatre pièces comportant une caractéristique commune. La façon dont ont peu aligner les pièces sont celles données par l\u0026rsquo;image :\nExemple de configurations gagnantes.\nLe joueur gagnant est celui qui pose la pièce qui amène à cet alignement. Cependant, il existe des configurations dans lesquelles aucun des deux joueurs n\u0026rsquo;est gagnant.\nLa configuration suivante ne permet à aucun des deux joueurs de réclamer la victoire :\nExemple de configuration nulle (aucun des deux joueurs ne gagne la partie).\nExtension du jeu Il a été prouvé par Luc Goossens sur son site que le jeu du Quarto est un jeu nulle. C\u0026rsquo;est-à-dire que si les deux joueurs jouent à chaque fois les meilleurs couts, aucun des deux ne peut gagner.\nPour contrer ce problème, nous mettons en place une version du Quarto à quatre niveaux de jeu :\nNiveau 1 : configuration gagnante : celle classique. L\u0026rsquo;alignement de quatre pièces possédant une caractéristique commune.\nExemple de partie gagnée dans le niveau 1. La couleur est la caractéristique commune.\nNiveau 2 : configurations gagnantes : celle du niveau 1 ainsi qu\u0026rsquo;une disposition de quatre pièces aillant une caractéristique en commun dans un carré de largueur 2.\nExemple de partie gagnée dans le niveau 2. Le type (creuse) des quatre pièces est la caractéristique commune.\nNiveau 3 : configurations gagnantes : celles des niveaux précédents ainsi que la disposition de quatre pièces (toujours avec une caractéristique commune) dans les coins d\u0026rsquo;un carré de largueur 3.\nExemple de partie gagnée dans le niveau 3. La hauteur (grande) des quatre pièces est la caractéristique commune.\nNiveau 4 : configurations gagnantes : celles des niveaux précédents, ainsi que quatre pièces (toujours avec une caractéristique commune) formant soit un losange de largueur deux ou qu\u0026rsquo;elles soient dans les coins d\u0026rsquo;un losange de largueur 3.\nExemple de deux parties gagnées dans le niveau 4. Que ce soit par la condition des coins ou encore du losange de largueur 3.\nImplémentation Tout le code associé à l\u0026rsquo;implémentation de la logique du jeu (et en aucun cas de l\u0026rsquo;interface) est décrit dans cette partie. L\u0026rsquo;intégralité de ce code est disponible sur le Github quarto.\nReprésentation d\u0026rsquo;une partie de jeu L\u0026rsquo;objectif de cette implémentation est d\u0026rsquo;être performante quant à son d\u0026rsquo;utilisation mémoires.\u0026quot; Cette contrainte est due à l\u0026rsquo;objectif d\u0026rsquo;utiliser cette implémentation par des algorithmes d\u0026rsquo;optimisation et de prise de décision dans un jeu. (MinMax, NégaMax \u0026hellip;).\nLes pièces Il y a 16 pièces dans ce jeu, chacune à quatre attributs ne pouvant prendre que deux valeurs. Nous avons donc décidé de représenter une pièce par un ensemble de 4 bit. Chaque bit représente une des quatre conditions suivantes :\nEst-ce que la pièce est marron ? Est-ce que la pièce est grande ? Est-ce que la pièce est creuse ? Est-ce que la pièce est un cube ? Si la condition est vérifiée, alors le bit vaut 1, 0 dans le cas contraire. Un exemple de telle représentation est donné par l\u0026rsquo;image ci-dessous :\nReprésentation de la petite pièce cylindrique marron qui est creuse selon notre représentation sur 4 bits.\nLe plateau Sur un plateau de Quarto, il y a 16 cases. De plus, nous avons déjà une représentation des pièces sur 4 bits. Nous allons donc utiliser un entier de 64 bits (\\(16 \\times 4 = 64\\)) où chaque bloc de 4 bits représentera une case de notre plateau de jeu. La première case sera la plus à gauche tandis que la dernière sera à droite.\nChaque case présente sur ce schéma est un groupe de 4 bits représentant une pièce.\nAvec cette implémentation, on se heurte à un problème. On ne peut pas représenter sur notre plateau l\u0026rsquo;absence de pièces sur une case. En effet, chaque combinaison possible sur les 4 bits est associée à une pièce. Pour résoudre ce problème, nous ajoutons donc un résumé de 16 bits. Chaque bit de ce résumé décrit la vacuité de la case de même indice.\nPar exemple, se résume à écrire un plateau qui n\u0026rsquo;admet des pièces qu\u0026rsquo;aux cases d\u0026rsquo;indice 1, 3, 7 et 10.\nL\u0026rsquo;état du jeu Maintenant qu\u0026rsquo;on sait représenter les pièces et le plateau de jeu, il nous faut enregistrer quelques informations supplémentaires :\nEst-ce que la partie est finie ? 1 si oui, 0 sinon. À qui est-ce le tour ? 0 pour Max et 1 pour Min. Quelle pièce le joueur doit-il placer ? Descriptions de la pièce (toujours sur 4 bits). À quel tour sommes-nous ? nombre en 0 et 16 sur 5 bits. Sur quel niveau de difficulté le jeu se joue-t-il ? Sur deux bits 00 : niveau 1 01 : niveau 2 10 : niveau 3 11 : niveau 4 Pour cela, nous allons rajouter \\(1 + 1 + 4 + 5 + 2 = 13\\) bits. Nous obtenons donc comme représentation de ces informations de la manière suivante :\nCe qui nous donne une représentation finale :\nQue nous représentons alors avec la structure suivante en C :\nstruct quarto_t { uint32_t summary; uint64_t board; }; Récupération des informations Pour interagir avec notre représentation, nous devons de ce faite utiliser les opérateurs bit à bit fournis par le C :\nOpérateur Descriptions ~ Opération de négation d\u0026rsquo;un nombre binaire. \u0026amp; Et logique. | Ou logique. ^ Ou exclusif (xor) Nous allons parfois avoir besoin de la valeur d\u0026rsquo;un bit à une certaine position. Notamment pour récupérer les valeurs dans le résumé. Prenons, par exemple, le cas où nous voudrions récupérer le bit de la case 15 de notre résumé.\nSur les schémas depuis le début, nous avons représenté nos indices de la gauche vers la droite, or en informatique, les nombres se lisent de la droite vers la gauche. Ce qui implique que le bit d\u0026rsquo;indice 31 dans notre dessin correspond en réalité au bit d\u0026rsquo;indice 0. On aura donc que l\u0026rsquo;opération\nprintf(\u0026#34;%b\u0026#34;, quarto.summary \u0026amp; 1); nous renvoie le bit d\u0026rsquo;indice 31 sur notre dessin.\nPour accéder à la valeur du bit recherché, il faut ainsi décaler (shift) cette case le plus à droite possible. Après cela, il suffit d\u0026rsquo;appliquer un et logique à ce bit et 1.\nIl faut aussi se rappeler qu\u0026rsquo;en informatique, les nombres se lisent de droite à gauche. Ainsi, pour récupérer le bit le plus à gauche, on devra faire plusieurs décalages (shift) de sens pour amener le bit à droite de la même manière que l\u0026rsquo;animation ci-dessous.\nPour rappel, les décalage en C se font dans les deux sens par les opérateurs suivants :\nOpérteur Descriptions a \u0026gt;\u0026gt; b Décale les bits de a de b case vers la droite. a \u0026lt;\u0026lt; b Décale les bits de a de b case vers la gauche. Selon la norme C23 , les bits ajoutés que ce soit à gauche ou à droite sont des zéros (outre le cas où le décalage est plus grand que la longueur du mot binaire)\nÉcriture des informations Description des types Pour simplifier les écritures de positionnement d\u0026rsquo;une pièce sur une certaine case, nous avons donné à l\u0026rsquo;énumération piece_t et position_t des valeurs particulières.\ntypedef enum { // ... C1_HUGE_HOLE_SQUARE = 0b0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110\u0026#39;0110, // ... } piece_t; typedef enum { // ... P3 = 0b0000\u0026#39;0000\u0026#39;0000\u0026#39;1111\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000\u0026#39;0000, // ... } position_t; Les notations 0b ainsi que les caractères ' dans la notation. Les binaires sont tous deux issus de la C23. La première permet d\u0026rsquo;écrire la valeur au format binaire. La seconde correspond simplement à un séparateur améliorant la lisibilité.\nL\u0026rsquo;objectif étant de mettre en place une écriture/lecture d\u0026rsquo;une position du plateau de manière très rapide. Pour ce faire, on représente les positions (position_t) sur 64 bits. Pour qu\u0026rsquo;il soit de la même taille que le plateau. Ces bits sont tous à zéro seul le mot de quatre bits qui correspond à la case en question admet ces bits à un.\nDe cette manière, pour récupérer la valeur de la pièce à la position 3 par exemple, il nous suffit de faire l\u0026rsquo;opération :\nquarto.board \u0026amp; P3; De même pour l\u0026rsquo;écriture, il nous suffira d\u0026rsquo;effectuer l\u0026rsquo;opération :\nquarto.board |= C1_HUGE_HOLE_SQUARE \u0026amp; P3; La raison pour laquelle l\u0026rsquo;écriture est si simple et que nous avons mis décris le type piece_t comme une répétition de la valeur de pièce sur 64 bits. Pour qu\u0026rsquo;un simple et logique permette de modifier la valeur à cette case.\nVérifications de fin de partie Nous n\u0026rsquo;allons pas détailler toutes les fonctions permettant de vérifier chaque condition de victoires selon les niveaux. En effet, une même logique est appliquée dans chacune de ces fonctions (de nom check__*) ; seul le parcours du plateau est différent.\nPour ce faire, on suppose que les quatre pièces que l\u0026rsquo;on souhaite tester sont [p1, p2, p3, p4]. On commence par initialiser un accumulateur qui représentera à chaque étape les points communs entre chaque pièce déjà traitée. Cet accumulateur a donc la description suivante :\nExemple et description de l\u0026rsquo;accumulateur. Ici, les propriétés communes sont la taille et la forme.\nMaintenant, pour calculer les points communs entre deux pièces, il faut obtenir les bits correspondant aux mêmes caractéristiques. On ne peut pas simplement utiliser un et logique, par exemple, si nos deux pièces sont jaunes, leur premier bit vaut toutes deux 0. Or, avec le et logique, nous aurions 0. Nous avons donc besoin d\u0026rsquo;un opérateur aillant pour la table de vérité :\na b Résultat 0 0 1 0 1 0 1 0 0 1 1 1 Par ailleurs, on peut implémenter cette table par la formule ~(a ^ b) (il s\u0026rsquo;agit de l\u0026rsquo;inverse d\u0026rsquo;un ou exclusif) en C. Il nous suffira alors d\u0026rsquo;effectuer un et logique entre cette valeur et la valeur actuelle de notre accumulateur.\nÀ la fin de ces calculs, il nous suffit de regarder la valeur de l\u0026rsquo;accumulateur. S\u0026rsquo;il vaut 0, il n\u0026rsquo;y a donc aucun point commun, sinon la partie est gagnée.\nComme évoqué précédemment, toutes les fonctions de tests utilisent ce procédé, seuls les algorithmes permettant de récupérer les pièces à comparer changent.\nInterface Tout d\u0026rsquo;abord, le fond du jeu utilise le module mbck présenté dans l\u0026rsquo;article \u0026ldquo;parallaxe_raylib\u0026rdquo;. Nous ne rentrerons pas dans les détails de l\u0026rsquo;implémentation Raylib. Il s\u0026rsquo;agit du premier gros projet que nous mettons en place avec celle-ci. De ce fait, le code a une qualité qui permet d\u0026rsquo;être instructif.\nCette partie sert à faire une démonstration des fonctionnalités du jeu. Une image vaut mieux que mille mots, voici une vidéo qui démontre une partie des fonctionnalités disponibles. Si vous avez des retours sur ce jeu, merci de nous contacter.\n","permalink":"http://localhost:1313/posts/quarto/","summary":"\u003cp\u003eDans le cadre d’un projet universitaire, nous étions invités à développer une version numérique du jeu de plateau \u003cem\u003eQuarto\u003c/em\u003e. Aux côtés de mon collègue \u003ca href=\"https://sagbot.com/\"\u003eE. HADDAG\u003c/a\u003e, nous avons ainsi tenté de concevoir l’implémentation la plus performante à notre portée de ce jeu. L\u0026rsquo;intégralité\nde ce projet a été réalisée en \u003cem\u003eC\u003c/em\u003e de l\u0026rsquo;interface à la mise en place du modèle.\u003c/p\u003e","title":"Quarto"},{"content":"Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l\u0026rsquo;ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l\u0026rsquo;état d\u0026rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l\u0026rsquo;animation ci-dessous.\nDans cet article, je m\u0026rsquo;intéresserai exclusivement aux LFSR opérant dans l\u0026rsquo;ensemble \\(\\mathbb{F}[X]_2^n\\), c\u0026rsquo;est-à-dire dans l\u0026rsquo;espace des nombres binaires (0 et 1). De plus, l\u0026rsquo;unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j\u0026rsquo;utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l\u0026rsquo;opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j\u0026rsquo;appellerai \\(s_n\\) la suite associée au LFSR illustré dans l\u0026rsquo;image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n\u0026rsquo;est pas compliqué : il suffit de respecter l\u0026rsquo;ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l\u0026rsquo;expresion réccurente de notre suite \\(s_n\\). Tout d\u0026rsquo;abords, il faut savoir que l\u0026rsquo;expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l\u0026rsquo;indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l\u0026rsquo;opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l\u0026rsquo;exemple du LFSR présenté dans l\u0026rsquo;image, considérons que le nombre généré au rang \\(i\\) correspond à l\u0026rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j\u0026rsquo;ai choisi de le représenter selon l\u0026rsquo;ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n\u0026rsquo;existe qu\u0026rsquo;un nombre limité de mots binaires sur 5 bits), il est inévitable qu\u0026rsquo;à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l\u0026rsquo;algorithme de Floyd, plus connu sous le nom de l\u0026rsquo;algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d\u0026rsquo;abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération.\nEssayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu\u0026rsquo;à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d\u0026rsquo;où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s\u0026rsquo;exercer est d\u0026rsquo;utiliser le site dcode, qui permet de déterminer la période d\u0026rsquo;un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l\u0026rsquo;indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d\u0026rsquo;entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l\u0026rsquo;algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nIl suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d\u0026rsquo;un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l\u0026rsquo;ensemble de \\(\\mathbb{F}_2^n\\) (à l\u0026rsquo;exception du vecteur nul, qui est rejeté puisqu\u0026rsquo;il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l\u0026rsquo;exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s\u0026rsquo;agit d\u0026rsquo;une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s\u0026rsquo;effectue par une combinaison linéaire des \\(c_i\\).\nOn peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu\u0026rsquo;une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d\u0026rsquo;un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nCette proposition se démontre à l\u0026rsquo;aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note.\nReprésentation sous forme de polynôme L\u0026rsquo;existence d\u0026rsquo;une représentation sous forme de suite d\u0026rsquo;un LFSR implique donc forcément l\u0026rsquo;existence d\u0026rsquo;une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d\u0026rsquo;un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Puisque l\u0026rsquo;on travaille dans \\(\\mathbb{F}_2\\), l\u0026rsquo;opération de soustraction (-) est en réalité équivalente à l\u0026rsquo;addition (+).\nSérie génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\).\nNous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s\u0026rsquo;écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l\u0026rsquo;aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\nOn peut aisément calculer la partie gauche de la formule, c\u0026rsquo;est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d\u0026rsquo;indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s\u0026rsquo;exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l\u0026rsquo;addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]","permalink":"http://localhost:1313/notes/lfsr/","summary":"\u003cp\u003eCette note offre une brève introduction aux \u003cem\u003eLFSR\u003c/em\u003e. Je me concentrerai sur les\néléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\u003c/p\u003e","title":"LFSR pratique"},{"content":"Dans cet article, nous verrons une méthode permettant de développer la composition de deux séries génératrices, que nous noterons \\(S \\circ T\\) à la main. Ce développement s’exprime sous la forme :\n$$ \\sum_{i} s_i \\left(\\sum_{j} t_j x^j\\right)^i. $$Pour illustrer cette méthode, nous supposerons que l’objectif est d’obtenir le coefficient de \\(x^3\\) dans ce développement.\nÉtape 1 : Décomposition de l’exposant La première étape consiste à décomposer l’exposant trois en sommes d\u0026rsquo;entiers inférieurs ou égaux à 3. Les décompositions possibles sont :\n$$ \\begin{split} 3 \u0026= 3,\\\\[1mm] \u0026= 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1. \\end{split} $$ Pour vérifier que nous n’avons omis aucune décomposition, voici le nombre de décompositions pour les entiers de 1 à 10 :\n1, 2, 3, 5, 7, 11, 15, 22, 30, 42.\nÉtape 2 : Expression en termes de \\(S \\circ T\\) Chaque décomposition permet d’identifier les termes correspondants dans la composition des séries. On associe ainsi un coefficient \\(s_i\\) en fonction du nombre de termes de la décomposition, et des produits de coefficients \\(t_j\\) correspondant aux valeurs ajoutées. Plus précisément :\nPour la décomposition \\(3 = 3\\), un seul terme est impliqué, ce qui conduit à : \\[ s_1(t_3). \\] Pour la décomposition \\(3 = 1 + 2\\), deux termes apparaissent, et l’on écrit : \\[ s_2(t_1 \\, t_2). \\] Pour la décomposition \\(3 = 1 + 1 + 1\\), trois termes identiques sont présents, ce qui donne : \\[ s_3(t_1 \\, t_1 \\, t_1) = s_3(t_1^3). \\] Ici, \\(s_i\\) et \\(t_j\\) sont respectivement les coefficients des séries \\(S\\) et \\(T\\). Le rang \\(i\\) de \\(s_i\\) correspond au nombre de termes dans la décomposition, tandis que les indices des \\(t_j\\) sont choisis pour que la somme de ces indices soit égale à 3.\nÉtape 3 : Incorporation des coefficients binomiaux Pour tenir compte des différentes permutations des termes dans chaque décomposition, nous introduisons des coefficients multinomiaux. En reprenant les termes obtenus précédemment, nous pouvons écrire :\n\\[ \\begin{aligned} s_1\\Bigl(\\binom{1}{1}\\, t_3^1\\Bigr) \u0026= s_1(t_3),\\\\[1mm] s_2\\Bigl(\\binom{2}{1,1}\\, t_1^1\\, t_2^1\\Bigr) \u0026= s_2(2\\,t_1t_2),\\\\[1mm] s_3\\Bigl(\\binom{3}{3}\\, t_1^3\\Bigr) \u0026= s_3(t_1^3). \\end{aligned} \\]Ici, dans la notation \\(\\binom{n}{k_1, k_2, \\dots, k_r}\\), le nombre \\(n\\) représente le nombre total de termes impliqués dans la décomposition, ce qui correspond à l’indice du coefficient \\(s_i\\). Les \\(k_j\\) indiquent quant à eux les exposants des différents \\(t_j\\). Par exemple, pour la décomposition \\(3 = 1 + 2\\), nous avons deux termes (donc \\(n=2\\)) et les exposants correspondants sont \\(1\\) pour \\(t_1\\) et \\(1\\) pour \\(t_2\\), d\u0026rsquo;où le coefficient multinomial \\(\\binom{2}{1,1} = 2\\).\nIl faut se rappeler que : $$\\binom{n}{k_1, k_2, \\dots, k_r} = \\dfrac{n!}{\\prod\\limits_{i}^r k_i!}$$ Et que pour \\(r = 1\\) alors : $$\\binom{n}{k} = \\dfrac{n!}{k!(n - k)!}$$ Conclusion En rassemblant l’ensemble des contributions, le développement pour le coefficient de \\(x^3\\) dans la composition \\(S \\circ T\\) s’écrit de la manière suivante :\n\\[ x^3\\Bigl[s_1(t_3) + s_2(2t_1t_2) + s_3(t_1^3)\\Bigr]. \\]En résumé, cette méthode permet de réaliser le développement de la composition de séries à la main. Pour vous exercer, essayez de calculer, de la même manière, les coefficients du terme en \\(x^4\\).\nLes décompositions de 4 sont :\n\\[ \\begin{aligned} 4 \u0026= 4,\\\\[1mm] \u0026= 1 + 3,\\\\[1mm] \u0026= 2 + 2,\\\\[1mm] \u0026= 1 + 1 + 2,\\\\[1mm] \u0026= 1 + 1 + 1 + 1. \\end{aligned} \\]Correspondance avec \\(s_i\\) et \\(t_j\\) :\n\\[ \\begin{alignat*}{3} \u0026 4 \u0026\u0026 = 4 \u0026\u0026 \\rightsquigarrow s_1(t_4),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 3 \u0026\u0026 \\rightsquigarrow s_2(t_1\\,t_3),\\\\[1mm] \u0026 \u0026\u0026 = 2 + 2 \u0026\u0026 \\rightsquigarrow s_2(t_2^2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 2 \u0026\u0026 \\rightsquigarrow s_3(t_1^2\\,t_2),\\\\[1mm] \u0026 \u0026\u0026 = 1 + 1 + 1 + 1 \u0026\u0026 \\rightsquigarrow s_4(t_1^4). \\end{alignat*} \\]Incorporation des coefficients binomiaux :\n\\[ x^4\\Bigl[s_1\\Bigl(\\binom{1}{1}t_4\\Bigr) + s_2\\Bigl(\\binom{2}{1,1}\\,t_1\\,t_3 + \\binom{2}{2}t_2^2\\Bigr) + s_3\\Bigl(\\binom{3}{2,1}t_1^2\\,t_2\\Bigr) + s_4\\Bigl(\\binom{4}{4}t_1^4\\Bigr)\\Bigr]. \\]En développant ces coefficients, on obtient :\n\\[ x^4\\Bigl[s_1(t_4) + s_2\\bigl(2\\,t_1\\,t_3 + t_2^2\\bigr) + s_3\\bigl(3\\,t_1^2\\,t_2\\bigr) + s_4(t_1^4)\\Bigr]. \\]","permalink":"http://localhost:1313/notes/devellopement_serie/","summary":"","title":"Développement de série à la main"},{"content":"La mesure est l\u0026rsquo;opération qui permet d\u0026rsquo;obtenir une information d\u0026rsquo;un qubit sur un registre classique. C\u0026rsquo;est donc l\u0026rsquo;une des opérations les plus importantes en informatique quantique.\nTout d\u0026rsquo;abord, il faut savoir qu\u0026rsquo;une mesure s\u0026rsquo;effectue à l\u0026rsquo;aide d\u0026rsquo;un opérateur, que nous noterons \\(\\mathcal{O}\\). Pour être valide, cet opérateur doit être hermitien :\n$$ \\text{Si } \\mathcal{O}^{\\dagger} = \\mathcal{O} \\text{ alors } \\mathcal{O} \\text{ est }\\textbf{hermitien} $$ Une fois que nous avons établi cette propriété, l\u0026rsquo;opérateur \\(\\mathcal{O}\\) est qualifié d\u0026rsquo;observable. Pour effectuer une mesure, il convient alors de suivre les étapes suivantes :\nDéterminer les valeurs et vecteurs propres de l\u0026rsquo;observable. Pour rappels si : $$ \\mathcal{O}\\ket{\\phi} = \\lambda\\ket{\\phi}\\\\ $$ Alors : $$ \\begin{cases} \\lambda \\;\\;\\;\\textbf{ valeur propre}, \\\\ \\ket{\\phi} \\textbf{ vecteur propre}. \\end{cases} $$ On va chercher pour chaque valeur propre \\(\\lambda\\) à créer un espace vectoriel \\(E_\\lambda\\) aillant pour base les vecteurs propre associer à cette valeur propre. $$ E_\\lambda = Vect\\{\\ket{\\phi_0}, \\cdots, \\ket{\\phi_n}\\} $$ où les \\(\\ket{\\phi_i}\\) sont les vecteurs propres correspondant à la valeur propre \\(\\lambda\\). Définir les projecteurs associés. On définit le projecteur \\(P_\\lambda\\) par : $$ P_\\lambda = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i}\\bra{\\phi_i} $$ où \\(\\mathcal{B}(E_\\lambda)\\) représente la base de l\u0026rsquo;espace \\(E_\\lambda\\). Les projecteurs ainsi définis correspondent aux opérateurs que l\u0026rsquo;on applique sur le qubit à mesurer. Les projecteurs \\(P\\) respecte la propriété \\(P^2 = P\\).\nOpération de mesure. Il est maintenant temps d\u0026rsquo;appliquer notre mesure sur une fonction d\u0026rsquo;onde que l\u0026rsquo;on appellera \\(\\ket{\\psi}\\). Avant de procéder à cette opération, il est essentiel de bien comprendre son principe. Nous partons d\u0026rsquo;une fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\), qui est un vecteur dans un espace \\(A\\). Appliquer une mesure sur \\(\\ket{\\psi}\\) revient à projeter ce vecteur dans un nouvel espace. L\u0026rsquo;espace vers lequel \\(\\ket{\\psi}\\) sera projetée est l\u0026rsquo;un des \\(E_\\lambda\\), avec une probabilité déterminée. Pour réaliser ce changement de base, il suffit d\u0026rsquo;utiliser les projecteurs que nous avons calculés au préalable. En résumé, l\u0026rsquo;opération peut être illustrée par l\u0026rsquo;arbre suivant : Cependant, appliquer un projecteur \\(P_{\\lambda_i}\\) ne conserve pas la norme du vecteur. Cela signifie que, après l\u0026rsquo;application du projecteur, le vecteur ne restera plus sur la sphère de Bloch, ce qui empêche une nouvelle mesure de notre fonction d\u0026rsquo;onde \\(P_{\\lambda_i}\\ket{\\psi}\\). C\u0026rsquo;est pourquoi l\u0026rsquo;arbre de mesure doit être modifié, comme illustré ci-dessous : Grâce à cette multiplication par l\u0026rsquo;inverse de la probabilité, notée \\(\\mathbb{P}(E_{\\lambda_i})\\) d\u0026rsquo;appliquer notre projecteur, la norme reste la même. Cette probabilité est donnée par la formule suivante :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$ Dans le cas où \\(\\ket{\\psi}\\) est normalisé, \\(\\bra{\\psi} \\ket{\\psi} = 1\\).\nEn suivant ces étapes, vous pourrez réaliser la mesure. Le seul détail que j\u0026rsquo;ai omis est que, après l\u0026rsquo;application du projecteur, une information est transmise dans un registre classique. Cette information dépend du \\(\\lambda_i\\) correspondant. Par exemple, il est courant de considérer que pour \\(\\lambda = 1\\), le résultat enregistré dans le registre classique est 0, et pour \\(\\lambda = -1\\), il est 1. Je ne vais pas développer davantage sur ce sujet, n\u0026rsquo;étant pas suffisamment familier avec les propriétés physiques permettant cette interprétation matérielle.\nOptimisation des calculs Il est clair que le calcul le plus long de notre mesure sera \\(\\mathbb{P}(E_{\\lambda_i})\\). En reprenant notre formule :\n$$ \\mathbb{P}(E_{\\lambda_i}) = \\dfrac{\\bra{\\psi} P_{\\lambda_i} \\ket{\\psi}}{\\bra{\\psi} \\ket{\\psi}} $$Nous savons déjà que \\(\\bra{\\psi}\\ket{\\psi}\\) correspond au module au carré des coefficients de notre fonction d\u0026rsquo;onde \\(\\ket{\\psi}\\). Concernant le calcul de \\(P_{\\lambda_i}\\ket{\\psi}\\), nous avons :\n$$ P_{\\lambda_i} \\ket{\\psi} = \\sum_{\\ket{\\phi_i} \\in \\mathcal{B}(E_\\lambda)} \\ket{\\phi_i} \\bra{\\phi_i} \\ket{\\psi} $$On constate ainsi que si \\(\\ket{\\psi}\\) appartient déjà à la base \\(\\mathcal{B} (E_\\lambda)\\), il suffit de lire les coefficients associés. Cela permet de grandement accélérer le calcul. Par conséquent, il peut être intéressant d\u0026rsquo;envisager de changer la base de \\(\\ket{\\psi}\\) pour celle de notre espace propre \\(\\mathcal{B}(E_\\lambda)\\).\n","permalink":"http://localhost:1313/notes/mesure_quantique/","summary":"","title":"Mesure Quantique"},{"content":"Après avoir consulté l\u0026rsquo;exemple dédié au défilement parallaxe de la Raylib, j\u0026rsquo;ai décidé de créer un module en C pour rendre son implémentation plus propre et efficace (toujour à l\u0026rsquo;aide de la Raylib), lien vers le repertoire du module.\nPrincipe d\u0026rsquo;un fond parallaxe Le concept de fond en parallaxe consiste à faire défiler des images selon un décalage différent. Autrement dit, deux couches – le background et le foreground – sont décalées à des vitesses variées pour créer une illusion de profondeur et de mouvement continu. Une image vaut mieux que mille mots (un gif dans ce cas) :\nExemple tiré de Wikipédia\nPrincipe d\u0026rsquo;Implémentation Contrairement à ce que j\u0026rsquo;imaginais, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une seule image de très grande taille pour obtenir cet effet. En réalité, répéter plusieurs fois la même image permet de créer l\u0026rsquo;illusion d\u0026rsquo;un fond continu.\nFond simple Pour mettre en place ce mécanisme, on dispose de deux copies de notre fond, placées côte à côte. Comme on peut le voir dans l\u0026rsquo;animation ci-dessous, la première copie présente un bord vert tandis que la seconde affiche un bord violet. Le rectangle bleu représente l\u0026rsquo;écran de l\u0026rsquo;utilisateur (celui qui observe notre fond parallax). On déplace ensuite les deux images de gauche à droite et, dès que le bord droit de la seconde image est atteint, le décalage est réinitialisé.\nL\u0026rsquo;image de fond utilisée est celle de Edermunizz\nJe me suis permis de qualifier cette version de fond simple, car l\u0026rsquo;image utilisée se prolonge continuellement vers la droite. En effet, le motif obtenu en plaçant côte à côte la même image est continu, ce qui facilite son implémentation. Cependant, ce type de fond n\u0026rsquo;est pas le plus courant ; il était donc nécessaire de prévoir une version alternative capable d\u0026rsquo;utilisé des images ne possédant pas cette propriété.\nFond difficile Comme expliqué précédemment, certaines images, comme celle-ci, ne se prêtent pas à une simple répétition.\nMagnifique croquis de Mayotte, réalisé par moi-même\nPour remédier à ce problème, l\u0026rsquo;idée consiste à effectuer une rotation horizontale de la seconde image. Ce flip permet de créer une continuité dans le motif.\nOn pourrait alors penser qu\u0026rsquo;il suffirait d\u0026rsquo;appliquer la méthode décrite dans la section précédente pour animer le fond. Cependant, cela ne fonctionne pas : il manque une partie du motif, ce qui engendre une sensation de téléportation lors du décalage. Pour mieux illustrer ce problème, observons une version montrant le mouvement complet du fond.\nÀ l\u0026rsquo;aide de cette image, identifiez la zone problématique de notre première implémentation. Il s\u0026rsquo;agit de la zone de transition entre la deuxième et la troisième image, mise en évidence par la teinte violette sur l\u0026rsquo;image ci-dessous.\nEn effet, en appliquant l\u0026rsquo;implémentation précédente, la réinitialisation des deux images provequera un effet de téléportation visuelle de notre fond. Si vous n\u0026rsquo;êtes toujours pas convaincu, voici un gif illustrant notre implémentation précédente.\nOn constate explicitement, à l\u0026rsquo;écran de l\u0026rsquo;utilisateur (représenté par le rectangle bleu), l\u0026rsquo;île n\u0026rsquo;est jamais affichée dans son intégralité. Une transition brutale se produit, où le début de l\u0026rsquo;île apparaît subitement à droite, remplaçant la partie gauche.\nPour résoudre ce problème, ajouter seulement une troisième image. Cette troisième image permet de revenir au premier cas, où l\u0026rsquo;image de départ est identique à celle utilisée lors de la réinitialisation. Pour s\u0026rsquo;en mettre d\u0026rsquo;accord, il suffit de regarder l\u0026rsquo;image ci-dessus qui représenter un mouvement complet de notre motif.\nPar ailleurs, dans les deux exemples présentés — que ce soit avec l\u0026rsquo;utilisation d\u0026rsquo;une image simple ou d\u0026rsquo;une image plus difficile — j\u0026rsquo;ai opté pour un mouvement de gauche à droite, bien que l\u0026rsquo;inverse aurait également pu être envisagé. Le module offre ainsi la possibilité de personnaliser les paramètres de flip si nécéssaire ainsi que la direction du mouvement.\nMise en place du module Comme dans tout module C bien conçu, une seule structure, mbck_t (moving background type), est exposée à l\u0026rsquo;utilisateur. Celle-ci regroupe toutes les informations nécessaires à la configuration et à l\u0026rsquo;affichage du fond, à savoir la largeur et la hauteur de la fenêtre ainsi que le vers l\u0026rsquo;image de fond.\nL\u0026rsquo;élément central de ce module est la fonction mbck_physics_process, qui doit être appelée à chaque frame. En effet, elle se charge simultanément d\u0026rsquo;afficher le fond et de l\u0026rsquo;animer. Dans cette fonction, l\u0026rsquo;affichage des textures est réalisé (deux pour une image simple, trois dans le cas contraire) en appliquant un offset correspondant au mouvement.\nPour mettre en place ce mouvement, un compteur nommé scroll_b est intégré à la structure. Ce compteur représente le décalage des images par rapport à l\u0026rsquo;écran de l\u0026rsquo;utilisateur et est modifié par le paramètre delta passé à mbck_physics_process. Si delta est négatif, le fond se déplace de droite à gauche (l\u0026rsquo;offset est décrémenté), tandis que pour une valeur positive, le mouvement est inversé.\nEnfin, comme illustré dans les exemples précédents, la remise à zéro du fond intervient lorsque le décalage fait disparaître la première (ou la seconde, selon le sens du mouvement) image de la fenêtre.\nConclusion Grâce à ce module simple, en combinant plusieurs instances de la structure mbck_t, il est possible de créer des animations de fond d\u0026rsquo;une grande qualité. De plus, une multitude d\u0026rsquo;images destinées à ce type de fond sont disponibles sur des sites comme itch.io. Par exemple, j\u0026rsquo;ai pu y trouver des layers qui composent le fond présenté en exemple dans ce module :\nAuteur des Layers utilisé CraftPix\n","permalink":"http://localhost:1313/posts/parallaxe_raylib/","summary":"\u003cp\u003eAprès avoir consulté\nl\u0026rsquo;\u003ca href=\"https://github.com/michenriksen/til-example-site/blob/main/content/posts/rich-content.md\"\u003eexemple\u003c/a\u003e\ndédié au \u003cstrong\u003edéfilement parallaxe\u003c/strong\u003e de la \u003cem\u003eRaylib\u003c/em\u003e, j\u0026rsquo;ai décidé de créer un module\nen \u003cstrong\u003eC\u003c/strong\u003e pour rendre son implémentation plus propre et efficace (toujour à\nl\u0026rsquo;aide de la \u003cem\u003eRaylib\u003c/em\u003e),\n\u003cstrong\u003e\u003ca href=\"https://github.com/titusse3/mbck\"\u003elien vers le repertoire du module\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e","title":"Fond Parallaxe"}]