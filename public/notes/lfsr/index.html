<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LFSR pratique | renauxv</title>
<meta name="keywords" content="">
<meta name="description" content="Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les
éléments essentiels pour en saisir le principe, sans entrer dans l&rsquo;ensemble des
détails théoriques.">
<meta name="author" content="">
<link rel="canonical" href="https://renauxv.fr/notes/lfsr/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.579954d9aa9c58e0dc345e2e1d11231b738d9f08806b3af262235eeeda9dd040.css" integrity="sha256-V5lU2aqcWODcNF4uHREjG3ONnwiAazryYiNe7tqd0EA=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://renauxv.fr/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://renauxv.fr/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="32x32" href="https://renauxv.fr/assets/favicon.ico">
<link rel="apple-touch-icon" href="https://renauxv.fr/assets/favicon.ico">
<link rel="mask-icon" href="https://renauxv.fr/assets/favicon.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://renauxv.fr/notes/lfsr/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<meta property="og:url" content="https://renauxv.fr/notes/lfsr/">
  <meta property="og:site_name" content="renauxv">
  <meta property="og:title" content="LFSR pratique">
  <meta property="og:description" content="Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l’ensemble des détails théoriques.">
  <meta property="og:locale" content="fr-FR">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:published_time" content="2025-04-07T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-04-07T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LFSR pratique">
<meta name="twitter:description" content="Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les
éléments essentiels pour en saisir le principe, sans entrer dans l&rsquo;ensemble des
détails théoriques.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://renauxv.fr/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "LFSR pratique",
      "item": "https://renauxv.fr/notes/lfsr/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LFSR pratique",
  "name": "LFSR pratique",
  "description": "Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l\u0026rsquo;ensemble des détails théoriques.\n",
  "keywords": [
    
  ],
  "articleBody": "Cette note offre une brève introduction aux LFSR. Je me concentrerai sur les éléments essentiels pour en saisir le principe, sans entrer dans l’ensemble des détails théoriques.\nPour commencer, les LFSR sont des suites linéaires récurrentes employées en cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte à œufs, comme le montre l’ilustration ci-dessous.\nLe principe est assez simple : les valeurs visibles correspondent à l’état d’initialisation. Pour obtenir la valeur suivante, il suffit de reproduire exactement la méthode illustrée dans l’animation ci-dessous.\nDans cet article, je m’intéresserai exclusivement aux LFSR opérant dans l’ensemble \\(\\mathbb{F}[X]_2^n\\), c’est-à-dire dans l’espace des nombres binaires (0 et 1). De plus, l’unique opération utilisée est le xor (souvent noté \\(\\oplus\\)), dont la table de vérité est la suivante :\nA B A \\(\\oplus\\) B 0 0 0 0 1 1 1 0 1 1 1 0 Puisque je me limite à cet ensemble, j’utiliserai le symbole + à la place de \\(\\oplus\\), tout en continuant à désigner l’opération comme étant le xor.\nRéprésentation sous forme de récurence linéaire Dans la suite de cet article, j’appellerai \\(s_n\\) la suite associée au LFSR illustré dans l’image. Il faut comprendre que les valeurs contenues dans la boîte correspondent aux termes initiaux de la suite. Ce n’est pas compliqué : il suffit de respecter l’ordre des termes, qui sont indexés à partir de 0, en partant de la droite vers la gauche. Ainsi, pour notre LFSR, les termes initiaux sont les suivants :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_4 = 1 \\\\ \\end{cases} \\]Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients de l’expresion réccurente de notre suite \\(s_n\\). Tout d’abords, il faut savoir que l’expression sera de la forme :\n\\[ s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} \\]Les termes \\(s_{n-i}\\) proviennent du fait que notre boîte à œufs contient cinq valeurs. Pour déterminer les coefficients \\(c_i\\), il suffit de repérer les indices des symboles \\(\\oplus\\) dans notre schéma, en les parcourant cette fois de gauche à droite (contrairement à l’indexation des \\(s_i\\)). Comme le montre le dessin, on obtient ainsi :\n\\[ \\begin{aligned} s_n \u0026= 0 \\times s_{n-1} + 1 \\times s_{n-2} + 0 \\times s_{n-3} + 0 \\times s_{n-4} + 1 \\times s_{n-5} \\\\ \u0026= s_{n-2} + s_{n-5}. \\end{aligned} \\]Cela signifie que pour calculer le terme suivant, on additionne (en appliquant l’opération xor) le quatrième et le premier terme.\nPériodicité Maintenant que nous avons saisi son fonctionnement, intéressons-nous à quelques-unes de ses propriétés. Pour reprendre l’exemple du LFSR présenté dans l’image, considérons que le nombre généré au rang \\(i\\) correspond à l’ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le premier nombre noté (au rang 0) est \\([1, 0, 0, 1, 1]\\), le deuxième (au rang\n\\([0, 0, 1, 1, 0]\\) (j’ai choisi de le représenter selon l’ordre des \\(s_i\\)), et ainsi de suite. On notera cette suite de valeur \\(e_i\\) On constate que cette suite évolue dans \\(\\mathbb{F}_2^{5}\\). Par ailleurs, puisque la suite \\(s_n\\) est infinie et que \\(\\mathbb{F}_2^{5}\\) est un ensemble fini (il n’existe qu’un nombre limité de mots binaires sur 5 bits), il est inévitable qu’à un certain rang, pour certains indices \\(n\\) et \\(n'\\), on ait :\n$$ s_n = s_{n'} $$Notre objectif étant de générer des nombres pseudo-aléatoires, il est important de connaître la période de cette suite pour déterminer si le LFSR est suffisamment performant (une période très longue étant souhaitable). Pour cela, nous utiliserons l’algorithme de Floyd, plus connu sous le nom de l’algorithme du lièvre et de la tortue.\nAlgorithme de Floyd Cet algorithme se déroule en deux étapes :\nTout d’abord, on cherche un rang \\(i \u003e 0\\) tel que \\(e_i = e_{2i}\\), où \\(e_i\\) représente le nombre généré par le LFSR au rang \\(i\\). Pour ce faire, il suffit de faire progresser le LFSR et de comparer les valeurs obtenues. Une fois cette égalité identifiée, on enregistre ce rang sous le nom \\(n\\).\nEnsuite, on répète la procédure en recherchant une égalité similaire pour \\(e_{i+1} = e_{2(i+1)}\\) avec \\(i \u003e n\\). Dès que cette condition est remplie, on note le rang \\(i + 1\\) sous le nom \\(n_1\\).\nLa période de la suite, notée \\(\\lambda\\), est alors donnée par\n\\[ \\lambda = n_1 - n. \\] Note On ne prend pas en compte \\(e_0\\), le nombre généré par les valeurs initiales du LFSR avant toute opération. Essayer de trouver la période associée au LFSR défini par la suite \\(s_n\\) :\n\\[ \\begin{cases} s_0 = 1 \\\\ s_1 = 0 \\\\ s_2 = 0 \\\\ s_3 = 1 \\\\ s_n = s_{n-2} + s_{n-4}\\\\ \\end{cases} \\] Correction Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le LFSR jusqu’à obtenir les égalités \\(e_i = e_{2i}\\) et \\(e_{i + 1} = e_{2(i + 1)}\\).\nPour ce faire :\nDans cette image, les nombres sont écrits sous forme de vecteurs, avec \\(s_0\\) représentant le bit le plus haut.\nOn trouve ainsi que \\(n = 6\\) et \\(n_1 = 12\\), d’où la période du LFSR est \\(\\lambda = 6\\).\nUn bon moyen de s’exercer est d’utiliser le site dcode, qui permet de déterminer la période d’un LFSR que vous aurez vous-même conçu. Veillez toutefois à bien prendre en compte l’indexation des coefficients, qui diffère de celle utilisée dans cette note.\nNous avons ainsi calculé la période. Cependant, certaines suites ne commencent pas directement par leur cycle périodique complet ; il peut exister un chemin préliminaire avant d’entrer dans le cycle. On appelle cette phase la queue de la suite. Pour calculer la longueur de la queue, notée \\(\\mu\\), il suffit de réappliquer la première étape de l’algorithme de Floyd, mais cette fois-ci en recherchant \\(e_i = e_{i + \\lambda}\\), en commençant à \\(i = 0\\) (comme précédemment).\nEssayer maintenant de calculer \\(\\mu\\) de la suite donner précédament.\nCorrection Il suffit de reprendre le calcule des \\(e_i\\) précédent, on remarque alors que \\(e_0 = e_{0 + 6}\\) et que donc \\(\\mu = 0\\).\nPériode maximale Une propriété essentielle et relativement facile à comprendre est la valeur de la période maximale d’un LFSR. Si notre LFSR prend des valeurs dans \\(\\mathbb{F}_2^n\\), cela signifie que sa période couvre l’ensemble de \\(\\mathbb{F}_2^n\\) (à l’exception du vecteur nul, qui est rejeté puisqu’il correspond à un élément absorbant).\nAinsi, la période maximale est : \\[ |\\mathbb{F}_2^n| - 1 = 2^n - 1. \\]Représentation sous forme matricielle Tout comme on peut représenter notre LFSR sous forme de suite linéaire, il est également possible de l’exprimer sous forme de matrice.\nPour entrer dans les détails, il convient de distinguer deux matrices. La première, notée \\(S\\), regroupe les \\(s_i\\) :\n\\[ S = \\begin{pmatrix} s_0 \\\\ s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-1} \\end{pmatrix} \\]où \\(l\\) correspond au nombre de valeurs présentes dans notre boîte à œufs.\nLa deuxième matrice, notée \\(M\\), représente la logique de rétroaction de notre LFSR. Il s’agit d’une matrice carrée de dimension \\(l \\times l\\) de la forme suivante :\n\\[ M = \\begin{pmatrix} 0 \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 1 \\\\ c_l \u0026 c_{l - 1} \u0026 \\cdots \u0026 c_2 \u0026 c_1 \\end{pmatrix} \\]Pour se convaincre de cette écriture, calculons \\(M \\times S\\) :\n\\[ M \\times S = \\begin{pmatrix} s_1 \\\\ s_2 \\\\ \\vdots \\\\ s_{l-2}\\\\ s_{l-1}\\\\ c_ls_0 + c_{l-1}s_1 + \\cdots + c_1s_{l - 1} \\end{pmatrix} \\]On retrouve ainsi le décalage qui fait disparaître \\(s_0\\) et le calcul de \\(s_l\\) s’effectue par une combinaison linéaire des \\(c_i\\).\nNote On peut remarquer que, pour calculer les \\(e_i\\) utilisés pour déterminer la période, il suffit de poser : \\[ e_0 = S, \\; e_n = M\\times e_{n - 1}. \\] Périodicité On dit qu’une suite est périodique si et seulement si \\(\\mu = 0\\). Dans le cas d’un LFSR, cela équivaut à dire que \\(c_l \\neq 0\\), où \\(l\\) représente le nombre de valeurs de notre boîte à œufs.\nNote Cette proposition se démontre à l’aide de la représentation matricielle des LFSR, mais cette démonstration dépasse le cadre de cette note. Représentation sous forme de polynôme L’existence d’une représentation sous forme de suite d’un LFSR implique donc forcément l’existence d’une représentation sous de série et donc dans certain cas de polynôme.\nPolynôme de rétroaction On définit le polynôme de rétroaction d’un LFSR de la manière suivante :\n\\[ P(X) = 1 - \\sum_{i = 1}^l c_i x^i \\] Note Puisque l’on travaille dans \\(\\mathbb{F}_2\\), l’opération de soustraction (-) est en réalité équivalente à l’addition (+). Série génératrice ordinaire Rappelons que la série génératrice ordinaire associée à une suite \\(s_n\\) est définie par :\n\\[ S(X) = \\sum_{n \\geq 0} s_n x^n \\] Note Petit rappel sur les séries : \\(S\\) est inversible si et seulement si \\(s_0 = 0\\). Nous disposons des deux propriétés suivantes concernant \\(s_n\\) :\nLa suite \\(s_n\\) est un LFSR si et seulement si sa série génératrice peut s’écrire sous la forme \\[ S(X) = \\dfrac{P_1(X)}{P_2(X)}, \\] où \\(P_1(X)\\) et \\(P_2(X)\\) sont deux polynômes.\nSi \\(s_n\\) est un LFSR, alors il existe une écriture de la forme \\[ S(X) = \\dfrac{Q(X)}{P(X)}, \\] où \\(P(X)\\) est le polynôme de rétroaction et \\(Q(X)\\) est un polynôme tel que \\(\\deg Q(X) \u003c l\\) (rappelons que \\(l\\) correspond au nombre de valeurs dans notre boîte à œufs).\nCalcul de \\(Q(X)\\) Sans entrer dans les détails de démonstration, il est possible de déterminer \\(Q(X)\\) à l’aide de la formule suivante :\n\\[ Q(X) = \\sum_{i = 0}^{l - 1} s_i x^i - \\sum_{n = 1}^{l - 1} \\sum_{\\substack{i + j = n\\\\i \\geq 0\\\\j \\geq 1}} s_i c_j x^n \\]Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier LFSR que nous avons examiné :\nOn dispose alors des informations suivantes :\n\\(i\\) 0 1 2 3 4 5 \\(s_i\\) 1 0 0 1 1 \\(c_i\\) 0 1 0 0 1 On peut aisément calculer la partie gauche de la formule, c’est-à-dire la somme\n\\[ \\sum_{i = 0}^{l - 1} s_i x^i. \\]Dans notre exemple, cette somme se simplifie en :\n\\[ 1 + x^3 + x^4. \\]Pour la partie droite, il faut observer que, pour chaque entier \\(n\\) allant de 1 à \\(l - 1\\), on doit sommer les produits \\(s_i \\times c_j\\) pour tous les couples d’indices tels que \\(i + j = n\\). Le résultat de cette somme correspond au coefficient de \\(x^n\\).\nExaminons cela pour notre exemple :\n\\(n\\) Expression Résultat 1 \\(s_0c_1\\) \\(0\\) 2 \\(s_0c_2 + s_1c_1\\) \\(1 + 0 = 1\\) 3 \\(s_0c_3 + s_1c_2 + s_2c_1\\) \\(0 + 0 + 0 = 0\\) 4 \\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\\) \\(0 + 0 + 0 + 0 = 0\\) La somme de droite s’exprime donc comme :\n\\[ x^2. \\]En combinant les deux parties — en rappelant que dans \\(\\mathbb{F}_2\\) la soustraction est équivalente à l’addition — on obtient :\n\\[ Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4. \\]",
  "wordCount" : "1907",
  "inLanguage": "en",
  "datePublished": "2025-04-07T00:00:00Z",
  "dateModified": "2025-04-07T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://renauxv.fr/notes/lfsr/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "renauxv",
    "logo": {
      "@type": "ImageObject",
      "url": "https://renauxv.fr/assets/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://renauxv.fr/" accesskey="h" title="renauxv (Alt + H)">renauxv</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://renauxv.fr/posts" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://renauxv.fr/notes" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://renauxv.fr/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://renauxv.fr/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://renauxv.fr/">Home</a>&nbsp;»&nbsp;<a href="https://renauxv.fr/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      LFSR pratique
    </h1>
    <div class="post-meta"><span title='2025-04-07 00:00:00 +0000 UTC'>April 7, 2025</span>&nbsp;·&nbsp;<span>9 min</span>

</div>
  </header> 
  <div class="post-content"><p>Cette note offre une brève introduction aux <em>LFSR</em>. Je me concentrerai sur les
éléments essentiels pour en saisir le principe, sans entrer dans l&rsquo;ensemble des
détails théoriques.</p>
<p>Pour commencer, les <em>LFSR</em> sont des suites linéaires récurrentes employées en
cryptographie afin de générer des nombres de façon pseudo-aléatoire. La manière
la plus intuitive de les illustrer consiste à utiliser une analogie avec une boîte
à œufs, comme le montre l&rsquo;ilustration ci-dessous.</p>
<p><img alt="Image d&rsquo;un <em>LFSR</em>" loading="lazy" src="https://i.imgur.com/FMELxUF.png"></p>
<p>Le principe est assez simple : les valeurs visibles correspondent à l&rsquo;état
d&rsquo;initialisation. Pour obtenir la valeur suivante, il suffit de reproduire
exactement la méthode illustrée dans l&rsquo;animation ci-dessous.</p>
<p><img alt="Animation <em>LFSR</em>" loading="lazy" src="https://i.imgur.com/zxNV38p.gif"></p>
<hr>
<p>Dans cet article, je m&rsquo;intéresserai exclusivement aux <em>LFSR</em> opérant dans
l&rsquo;ensemble \(\mathbb{F}[X]_2^n\), c&rsquo;est-à-dire dans l&rsquo;espace des nombres
binaires (0 et 1). De plus, l&rsquo;unique opération utilisée est le <em>xor</em> (souvent
noté \(\oplus\)), dont la table de vérité est la suivante :</p>
<table>
  <thead>
      <tr>
          <th>A</th>
          <th>B</th>
          <th>A \(\oplus\) B</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>0</td>
          <td>0</td>
      </tr>
      <tr>
          <td>0</td>
          <td>1</td>
          <td>1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>0</td>
          <td>1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>0</td>
      </tr>
  </tbody>
</table>
<p>Puisque je me limite à cet ensemble, j&rsquo;utiliserai le symbole + à la place de
\(\oplus\), tout en continuant à désigner l&rsquo;opération comme étant le <em>xor</em>.</p>
<h2 id="réprésentation-sous-forme-de-récurence-linéaire">Réprésentation sous forme de récurence linéaire<a hidden class="anchor" aria-hidden="true" href="#réprésentation-sous-forme-de-récurence-linéaire">#</a></h2>
<p>Dans la suite de cet article, j&rsquo;appellerai \(s_n\) la suite associée au <em>LFSR</em>
illustré dans l&rsquo;image. Il faut comprendre que les valeurs contenues dans la
boîte correspondent aux termes initiaux de la suite. Ce n&rsquo;est pas compliqué : il
suffit de respecter l&rsquo;ordre des termes, qui sont indexés à partir de 0, en
partant de la droite vers la gauche. Ainsi, pour notre <em>LFSR</em>, les termes
initiaux sont les suivants :</p>
\[
\begin{cases}
s_0 = 1 \\
s_1 = 0 \\
s_2 = 0 \\
s_3 = 1 \\
s_4 = 1 \\
\end{cases}
\]<p>Une fois ces termes initiaux trouvé, il nous suffis de trouver les coefficients
de l&rsquo;expresion réccurente de notre suite \(s_n\). Tout d&rsquo;abords, il faut savoir
que l&rsquo;expression sera de la forme :</p>
\[
s_n = c_1 s_{n - 1} + c_2 s_{n - 2} + c_3 s_{n - 3} + c_4 s_{n - 4} + c_5 s_{n - 5} 
\]<p>Les termes \(s_{n-i}\) proviennent du fait que notre boîte à œufs contient cinq
valeurs. Pour déterminer les coefficients \(c_i\), il suffit de repérer les
indices des symboles \(\oplus\) dans notre schéma, en les parcourant cette fois
de gauche à droite (contrairement à l&rsquo;indexation des \(s_i\)). Comme le montre
le dessin, on obtient ainsi :</p>
<p><img alt="Image montrant les indices des C_i" loading="lazy" src="https://i.imgur.com/LMS4xUd.png"></p>
\[
\begin{aligned}
s_n &= 0 \times s_{n-1} + 1 \times s_{n-2} + 0 \times s_{n-3} + 
    0 \times s_{n-4} + 1 \times s_{n-5} \\
    &= s_{n-2} + s_{n-5}.
\end{aligned}
\]<p>Cela signifie que pour calculer le terme suivant, on additionne (en appliquant
l&rsquo;opération xor) le quatrième et le premier terme.</p>
<h2 id="périodicité">Périodicité<a hidden class="anchor" aria-hidden="true" href="#périodicité">#</a></h2>
<p>Maintenant que nous avons saisi son fonctionnement, intéressons-nous à
quelques-unes de ses propriétés. Pour reprendre l&rsquo;exemple du <em>LFSR</em> présenté
dans l&rsquo;image, considérons que le nombre généré au rang \(i\) correspond à
l&rsquo;ensemble des valeurs affichées dans la boîte à œufs à ce moment. Ainsi, le
premier nombre noté (au rang 0) est \([1, 0, 0, 1, 1]\), le deuxième (au rang</p>
<ol>
<li>\([0, 0, 1, 1, 0]\) (j&rsquo;ai choisi de le représenter selon l&rsquo;ordre des
\(s_i\)), et ainsi de suite. On notera cette suite de valeur \(e_i\)</li>
</ol>
<p>On constate que cette suite évolue dans \(\mathbb{F}_2^{5}\). Par ailleurs,
puisque la suite \(s_n\) est infinie et que \(\mathbb{F}_2^{5}\) est un ensemble
fini (il n&rsquo;existe qu&rsquo;un nombre limité de mots binaires sur 5 bits), il est
inévitable qu&rsquo;à un certain rang, pour certains indices \(n\) et \(n'\), on ait :</p>
$$
  s_n = s_{n'}
$$<p>Notre objectif étant de générer des nombres pseudo-aléatoires, il est important
de connaître la période de cette suite pour déterminer si le <em>LFSR</em> est
suffisamment performant (une période très longue étant souhaitable). Pour cela,
nous utiliserons l&rsquo;algorithme de <strong>Floyd</strong>, plus connu sous le nom de
l&rsquo;algorithme du <em>lièvre et de la tortue</em>.</p>
<h3 id="algorithme-de-floyd">Algorithme de <strong>Floyd</strong><a hidden class="anchor" aria-hidden="true" href="#algorithme-de-floyd">#</a></h3>
<p>Cet algorithme se déroule en deux étapes :</p>
<ol>
<li>
<p>Tout d&rsquo;abord, on cherche un rang \(i > 0\) tel que \(e_i = e_{2i}\), où
\(e_i\) représente le nombre généré par le <em>LFSR</em> au rang \(i\). Pour ce faire,
il suffit de faire progresser le <em>LFSR</em> et de comparer les valeurs obtenues.
Une fois cette égalité identifiée, on enregistre ce rang sous le nom \(n\).</p>
</li>
<li>
<p>Ensuite, on répète la procédure en recherchant une égalité similaire pour
\(e_{i+1} = e_{2(i+1)}\) avec \(i > n\). Dès que cette condition est remplie,
on note le rang \(i + 1\) sous le nom \(n_1\).</p>
</li>
</ol>
<p>La période de la suite, notée \(\lambda\), est alors donnée par<br>
</p>
\[
\lambda = n_1 - n.
\]<figure
  role="note"
  id="admonition-00"
  aria-labelledby="admonition-caption-00"
  class="admonition note  not-prose"
>
  <div class="flex items-center space-x-2 pb-2 font-semibold">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      fill="none"
      stroke="currentColor"
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      class="lucide lucide-info"
    >
      <circle cx="12" cy="12" r="10" />
      <path d="M12 16v-4M12 8h.01" />
    </svg>

    <figcaption id="admonition-caption-00">
        Note
    </figcaption>
  </div>

  <div class="prose pl-8 text-inherit marker:text-inherit">
    On ne prend pas en compte \(e_0\), le nombre généré par les valeurs initiales
du <em>LFSR</em> avant toute opération.
  </div>
</figure>

<p>Essayer de trouver la période associée au <em>LFSR</em> défini par la suite \(s_n\) :</p>
\[
\begin{cases}
s_0 = 1 \\
s_1 = 0 \\
s_2 = 0 \\
s_3 = 1 \\
s_n = s_{n-2} + s_{n-4}\\
\end{cases}
\]<details>
  <summary>Correction</summary>
<p>Comme évoqué ci-dessus, il suffit de calculer les nombres générés par le
<em>LFSR</em> jusqu&rsquo;à obtenir les égalités \(e_i = e_{2i}\) et
\(e_{i + 1} = e_{2(i + 1)}\).</p>
<p>Pour ce faire :</p>
<p><img alt="Réponse" loading="lazy" src="https://i.imgur.com/3AbtadJ.png"></p>
<p>Dans cette image, les nombres sont écrits sous forme de vecteurs, avec
\(s_0\) représentant le bit le plus haut.</p>
<p>On trouve ainsi que \(n = 6\) et \(n_1 = 12\), d&rsquo;où la période du <em>LFSR</em> est
\(\lambda = 6\).</p>
<p>Un bon moyen de s&rsquo;exercer est d&rsquo;utiliser le site <a href="https://www.dcode.fr/registre-decalage-retroaction-lineaire">dcode</a>,
qui permet de déterminer la période d&rsquo;un LFSR que vous aurez vous-même conçu.
Veillez toutefois à bien prendre en compte l&rsquo;indexation des coefficients, qui
diffère de celle utilisée dans cette note.</p>
</details>
<hr>
<p>Nous avons ainsi calculé la période. Cependant, certaines suites ne commencent
pas directement par leur cycle périodique complet ; il peut exister un chemin
préliminaire avant d&rsquo;entrer dans le cycle. On appelle cette phase la <em>queue</em> de
la suite. Pour calculer la longueur de la <em>queue</em>, notée \(\mu\), il suffit de
réappliquer la première étape de l&rsquo;algorithme de Floyd, mais cette fois-ci en
recherchant \(e_i = e_{i + \lambda}\), en commençant à \(i = 0\) (comme
précédemment).</p>
<p>Essayer maintenant de calculer \(\mu\) de la suite donner précédament.</p>
<details>
  <summary>Correction</summary>
<p>Il suffit de reprendre le calcule des \(e_i\) précédent, on remarque alors
que \(e_0 = e_{0 + 6}\) et que donc \(\mu = 0\).</p>
</details>
<hr>
<h3 id="période-maximale">Période maximale<a hidden class="anchor" aria-hidden="true" href="#période-maximale">#</a></h3>
<p>Une propriété essentielle et relativement facile à comprendre est la valeur de
la période maximale d&rsquo;un <em>LFSR</em>. Si notre <em>LFSR</em> prend des valeurs dans
\(\mathbb{F}_2^n\), cela signifie que sa période couvre l&rsquo;ensemble de
\(\mathbb{F}_2^n\) (à l&rsquo;exception du vecteur nul, qui est rejeté puisqu&rsquo;il
correspond à un élément absorbant).</p>
<p>Ainsi, la période maximale est :
</p>
\[
  |\mathbb{F}_2^n| - 1 = 2^n - 1.
\]<h2 id="représentation-sous-forme-matricielle">Représentation sous forme matricielle<a hidden class="anchor" aria-hidden="true" href="#représentation-sous-forme-matricielle">#</a></h2>
<p>Tout comme on peut représenter notre <em>LFSR</em> sous forme de suite linéaire, il
est également possible de l&rsquo;exprimer sous forme de matrice.</p>
<p>Pour entrer dans les détails, il convient de distinguer deux matrices. La
première, notée \(S\), regroupe les \(s_i\) :</p>
\[
S = \begin{pmatrix}
s_0 \\
s_1 \\
s_2 \\
\vdots \\
s_{l-1}
\end{pmatrix}
\]<p>où \(l\) correspond au nombre de valeurs présentes dans notre boîte à œufs.</p>
<p>La deuxième matrice, notée \(M\), représente la logique de rétroaction de notre
<em>LFSR</em>. Il s&rsquo;agit d&rsquo;une matrice carrée de dimension \(l \times l\) de la forme
suivante :</p>
\[
M = \begin{pmatrix}
0      & 1      & 0      & \cdots & 0      \\
0      & 0      & 1      & \cdots & 0      \\
\vdots & \vdots & \ddots & \ddots & \vdots \\
0      & 0      & \cdots & 0      & 1      \\
c_l    & c_{l - 1}    & \cdots & c_2 & c_1
\end{pmatrix}
\]<p>Pour se convaincre de cette écriture, calculons \(M \times S\) :</p>
\[
  M \times S = \begin{pmatrix}
s_1 \\
s_2 \\
\vdots \\
s_{l-2}\\
s_{l-1}\\
c_ls_0 + c_{l-1}s_1 + \cdots + c_1s_{l - 1}
\end{pmatrix}
\]<p>On retrouve ainsi le décalage qui fait disparaître \(s_0\) et le calcul de
\(s_l\) s&rsquo;effectue par une combinaison linéaire des \(c_i\).</p>
<figure
  role="note"
  id="admonition-01"
  aria-labelledby="admonition-caption-01"
  class="admonition note  not-prose"
>
  <div class="flex items-center space-x-2 pb-2 font-semibold">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      fill="none"
      stroke="currentColor"
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      class="lucide lucide-info"
    >
      <circle cx="12" cy="12" r="10" />
      <path d="M12 16v-4M12 8h.01" />
    </svg>

    <figcaption id="admonition-caption-01">
        Note
    </figcaption>
  </div>

  <div class="prose pl-8 text-inherit marker:text-inherit">
    <p>On peut remarquer que, pour calculer les \(e_i\) utilisés pour déterminer la
période, il suffit de poser :
</p>
\[
e_0 = S, \; e_n = M\times e_{n - 1}.
\]
  </div>
</figure>

<h3 id="périodicité-1">Périodicité<a hidden class="anchor" aria-hidden="true" href="#périodicité-1">#</a></h3>
<p>On dit qu&rsquo;une suite est <strong>périodique</strong> si et seulement si \(\mu = 0\). Dans le
cas d&rsquo;un <em>LFSR</em>, cela équivaut à dire que \(c_l \neq 0\), où \(l\) représente
le nombre de valeurs de notre boîte à œufs.</p>
<figure
  role="note"
  id="admonition-02"
  aria-labelledby="admonition-caption-02"
  class="admonition note  not-prose"
>
  <div class="flex items-center space-x-2 pb-2 font-semibold">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      fill="none"
      stroke="currentColor"
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      class="lucide lucide-info"
    >
      <circle cx="12" cy="12" r="10" />
      <path d="M12 16v-4M12 8h.01" />
    </svg>

    <figcaption id="admonition-caption-02">
        Note
    </figcaption>
  </div>

  <div class="prose pl-8 text-inherit marker:text-inherit">
    Cette proposition se démontre à l&rsquo;aide de la représentation matricielle des
<em>LFSR</em>, mais cette démonstration dépasse le cadre de cette note.
  </div>
</figure>

<h2 id="représentation-sous-forme-de-polynôme">Représentation sous forme de polynôme<a hidden class="anchor" aria-hidden="true" href="#représentation-sous-forme-de-polynôme">#</a></h2>
<p>L&rsquo;existence d&rsquo;une représentation sous forme de suite d&rsquo;un <em>LFSR</em> implique donc
forcément l&rsquo;existence d&rsquo;une représentation sous de série et donc dans certain
cas de polynôme.</p>
<h3 id="polynôme-de-rétroaction">Polynôme de rétroaction<a hidden class="anchor" aria-hidden="true" href="#polynôme-de-rétroaction">#</a></h3>
<p>On définit le <strong>polynôme de rétroaction</strong> d&rsquo;un <em>LFSR</em> de la manière suivante :</p>
\[
  P(X) = 1 - \sum_{i = 1}^l c_i x^i
\]<figure
  role="note"
  id="admonition-03"
  aria-labelledby="admonition-caption-03"
  class="admonition note  not-prose"
>
  <div class="flex items-center space-x-2 pb-2 font-semibold">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      fill="none"
      stroke="currentColor"
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      class="lucide lucide-info"
    >
      <circle cx="12" cy="12" r="10" />
      <path d="M12 16v-4M12 8h.01" />
    </svg>

    <figcaption id="admonition-caption-03">
        Note
    </figcaption>
  </div>

  <div class="prose pl-8 text-inherit marker:text-inherit">
    Puisque l&rsquo;on travaille dans \(\mathbb{F}_2\), l&rsquo;opération de soustraction (-)
est en réalité équivalente à l&rsquo;addition (+).
  </div>
</figure>

<h3 id="série-génératrice-ordinaire">Série génératrice ordinaire<a hidden class="anchor" aria-hidden="true" href="#série-génératrice-ordinaire">#</a></h3>
<p>Rappelons que la <strong>série génératrice ordinaire</strong> associée à une suite \(s_n\)
est définie par :</p>
\[
  S(X) = \sum_{n \geq 0} s_n x^n
\]<figure
  role="note"
  id="admonition-04"
  aria-labelledby="admonition-caption-04"
  class="admonition note  not-prose"
>
  <div class="flex items-center space-x-2 pb-2 font-semibold">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      fill="none"
      stroke="currentColor"
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      class="lucide lucide-info"
    >
      <circle cx="12" cy="12" r="10" />
      <path d="M12 16v-4M12 8h.01" />
    </svg>

    <figcaption id="admonition-caption-04">
        Note
    </figcaption>
  </div>

  <div class="prose pl-8 text-inherit marker:text-inherit">
    Petit rappel sur les séries : \(S\) est <strong>inversible</strong> si et seulement si
\(s_0 = 0\).
  </div>
</figure>

<p>Nous disposons des deux propriétés suivantes concernant \(s_n\) :</p>
<ol>
<li>
<p>La suite \(s_n\) est un <em>LFSR</em> si et seulement si sa série génératrice peut
s&rsquo;écrire sous la forme
</p>
\[
S(X) = \dfrac{P_1(X)}{P_2(X)},
\]<p>
où \(P_1(X)\) et \(P_2(X)\) sont deux polynômes.</p>
</li>
<li>
<p>Si \(s_n\) est un <em>LFSR</em>, alors il existe une écriture de la forme
</p>
\[
S(X) = \dfrac{Q(X)}{P(X)},
\]<p>
où \(P(X)\) est le <strong>polynôme de rétroaction</strong> et \(Q(X)\) est un polynôme tel que \(\deg Q(X) < l\) (rappelons que \(l\) correspond au nombre de valeurs dans notre boîte à œufs).</p>
</li>
</ol>
<h3 id="calcul-de">Calcul de \(Q(X)\)<a hidden class="anchor" aria-hidden="true" href="#calcul-de">#</a></h3>
<p>Sans entrer dans les détails de démonstration, il est possible de déterminer \(Q(X)\) à l&rsquo;aide de la formule suivante :</p>
\[
Q(X) = \sum_{i = 0}^{l - 1} s_i x^i - \sum_{n = 1}^{l - 1} \sum_{\substack{i + j = n\\i \geq 0\\j \geq 1}} s_i c_j x^n
\]<p>Cette formule peut sembler complexe au premier abord, mais elle est en réalité assez accessible. Prenons un exemple ensemble en reprenant le premier <em>LFSR</em> que nous avons examiné :</p>
<p><img alt="Image du premier <em>LFSR</em>" loading="lazy" src="https://i.imgur.com/FMELxUF.png"></p>
<p>On dispose alors des informations suivantes :</p>
<table border="1" style="border-collapse: collapse;">
  <tr>
    <th style="text-align: center;">\(i\)</th>
    <th style="text-align: center;">0</th>
    <th style="text-align: center;">1</th>
    <th style="text-align: center;">2</th>
    <th style="text-align: center;">3</th>
    <th style="text-align: center;">4</th>
    <th style="text-align: center;">5</th>
  </tr>
  <tr>
    <td style="text-align: center;">\(s_i\)</td>
    <td style="text-align: center;">1</td>
    <td style="text-align: center;">0</td>
    <td style="text-align: center;">0</td>
    <td style="text-align: center;">1</td>
    <td style="text-align: center;">1</td>
    <td style="text-align: center;"></td>
  </tr>
  <tr>
    <td style="text-align: center;">\(c_i\)</td>
    <td style="text-align: center;"></td>
    <td style="text-align: center;">0</td>
    <td style="text-align: center;">1</td>
    <td style="text-align: center;">0</td>
    <td style="text-align: center;">0</td>
    <td style="text-align: center;">1</td>
  </tr>
</table>
<p>On peut aisément calculer la partie gauche de la formule, c&rsquo;est-à-dire la somme</p>
\[
\sum_{i = 0}^{l - 1} s_i x^i.
\]<p>Dans notre exemple, cette somme se simplifie en :</p>
\[
1 + x^3 + x^4.
\]<p>Pour la partie droite, il faut observer que, pour chaque entier \(n\) allant de
1 à \(l - 1\), on doit sommer les produits \(s_i \times c_j\) pour tous les
couples d&rsquo;indices tels que \(i + j = n\). Le résultat de cette somme correspond
au coefficient de \(x^n\).</p>
<p>Examinons cela pour notre exemple :</p>
<table>
  <thead>
      <tr>
          <th>\(n\)</th>
          <th>Expression</th>
          <th>Résultat</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>\(s_0c_1\)</td>
          <td>\(0\)</td>
      </tr>
      <tr>
          <td>2</td>
          <td>\(s_0c_2 + s_1c_1\)</td>
          <td>\(1 + 0 = 1\)</td>
      </tr>
      <tr>
          <td>3</td>
          <td>\(s_0c_3 + s_1c_2 + s_2c_1\)</td>
          <td>\(0 + 0 + 0 = 0\)</td>
      </tr>
      <tr>
          <td>4</td>
          <td>\(s_0c_4 + s_1c_3 + s_2c_2 + s_3c_1\)</td>
          <td>\(0 + 0 + 0 + 0 = 0\)</td>
      </tr>
  </tbody>
</table>
<p>La somme de droite s&rsquo;exprime donc comme :</p>
\[
x^2.
\]<p>En combinant les deux parties — en rappelant que dans \(\mathbb{F}_2\) la soustraction est équivalente à l&rsquo;addition — on obtient :</p>
\[
Q(X) = 1 + x^3 + x^4 + x^2 = 1 + x^2 + x^3 + x^4.
\]

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>Renaux Verdiere Theo</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
